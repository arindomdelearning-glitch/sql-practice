SQL Daily Practice Plan – 6 Months (Basic → Advanced)
==========================================================

Instructions:
- Aim to solve 2–3 queries per day.
- For each day’s topic, write 2–3 different queries using that theme.
- You can assume simple sample tables such as:
  Employees(emp_id, first_name, last_name, dept_id, salary, hire_date)
  Departments(dept_id, dept_name, location)
  Customers(customer_id, name, country, signup_date)
  Orders(order_id, customer_id, order_date, amount, status)
  Products(product_id, product_name, category, price)
- As you get comfortable, increase difficulty by combining multiple ideas in one query.

----------------------------------------------------------
MONTH 1 – CORE SQL & JOINS (Days 1–30)
----------------------------------------------------------

Day 1:
  • Practice basic SELECT: write 2–3 queries selecting all columns, specific columns, and using simple column aliases from Employees.

Day 2:
  • Practice WHERE filters: write queries using =, >, <, BETWEEN, IN to filter Employees and Products.

Day 3:
  • Combine multiple conditions: write queries using AND, OR, and NOT to filter Customers and Orders.

Day 4:
  • ORDER BY: write queries sorting Employees by salary, hire_date, and name (ASC/DESC).

Day 5:
  • DISTINCT: write queries listing distinct job titles, distinct dept_id values, and distinct customer countries.

Day 6:
  • Simple functions: write queries using UPPER(), LOWER(), CONCAT()/||, LENGTH() on names and emails.

Day 7:
  • Mixed practice: 2–3 queries combining SELECT + WHERE + ORDER BY + functions together.

Day 8:
  • Aggregates (part 1): write queries using COUNT(*), COUNT(column), SUM(amount), AVG(salary), MIN/MAX(price).

Day 9:
  • Aggregates (part 2): practice aggregates with simple conditions in WHERE (e.g., only active customers, orders in the last year).

Day 10:
  • GROUP BY basics: write queries grouping by dept_id, country, category and calculating totals or counts.

Day 11:
  • GROUP BY + HAVING: write queries that filter groups (e.g., departments with average salary > X, customers with more than N orders).

Day 12:
  • GROUP BY multiple columns: group by (dept_id, location) or (country, status) and calculate aggregates.

Day 13:
  • INNER JOIN (2 tables): Employees ↔ Departments, Orders ↔ Customers; return combined information.

Day 14:
  • INNER JOIN (3 tables): Orders ↔ Customers ↔ Products; show who bought what and for how much.

Day 15:
  • LEFT JOIN: list all Customers and their Orders (including customers with no orders); list all Departments and Employees (including empty departments).

Day 16:
  • RIGHT/FULL OUTER JOIN (if supported): experiment with keeping all rows from one/both sides and understanding NULLs.

Day 17:
  • JOIN conditions & aliases: practice joins with table aliases, and ensure you avoid Cartesian products.

Day 18:
  • SELF JOIN: Employees table joined to itself to show manager–employee relationships or mentor–mentee pairs.

Day 19:
  • JOIN + GROUP BY: total order amount per customer, total salary per department using JOINs.

Day 20:
  • JOIN + WHERE + HAVING: find customers whose total spend is above a limit; departments with more than N employees.

Day 21:
  • Mixed joins practice: write 2–3 queries mixing INNER and LEFT JOIN with GROUP BY.

Day 22:
  • String operations: SUBSTRING on product codes, TRIM spaces, extract domain from email addresses.

Day 23:
  • Date basics: filter by date ranges, extract year/month/day, find orders in the last 30 days.

Day 24:
  • CASE expression: categorize salaries (Low/Medium/High), categorize order amounts (Small/Medium/Large).

Day 25:
  • Handling NULLs: use IS NULL / IS NOT NULL, COALESCE/IFNULL to replace NULLs with defaults.

Day 26:
  • Mix of functions: combine CASE, string and date functions in 2–3 queries.

Day 27:
  • Basic subqueries (non-correlated): employees with salary > average salary, customers whose total spend > overall average.

Day 28:
  • Subqueries in SELECT: add a column that shows total orders per customer or total employees per department.

Day 29:
  • Subqueries in FROM (derived tables): aggregate in a subquery and then filter or join on that result.

Day 30:
  • Month 1 review: write 2–3 complex queries mixing JOINs, GROUP BY, HAVING, and basic subqueries.

----------------------------------------------------------
MONTH 2 – SUBQUERIES, CTEs, SET OPS & DML BASICS (Days 31–60)
----------------------------------------------------------

Day 31:
  • Correlated subqueries: employees whose salary > department average; products priced above category average.

Day 32:
  • EXISTS: find customers who have at least one order; departments that have employees.

Day 33:
  • NOT EXISTS: find products never ordered; customers without any orders.

Day 34:
  • IN vs EXISTS: solve the same problem using IN and EXISTS; compare readability.

Day 35:
  • ANY / ALL (if supported): employees whose salary > ALL salaries in another department; prices lower than ANY competitor.

Day 36:
  • Set operations – UNION: combine active and archived customers or employees from two regions.

Day 37:
  • UNION vs UNION ALL: demonstrate how UNION removes duplicates while UNION ALL keeps them.

Day 38:
  • INTERSECT (if supported): find emails common to two different email lists.

Day 39:
  • EXCEPT / MINUS (if supported): find customers in table A but not in table B.

Day 40:
  • Find duplicate records: locate duplicate emails or duplicate (first_name, last_name, birthdate) combinations.

Day 41:
  • INSERT basics: write INSERT INTO…VALUES and INSERT INTO…SELECT for Customers or Products.

Day 42:
  • UPDATE basics: increase salary by 10% for certain employees; change order status from ‘PENDING’ to ‘COMPLETED’.

Day 43:
  • DELETE basics: delete test data; delete customers with no orders (careful with conditions).

Day 44:
  • Safe DML: write SELECT queries that preview rows to be UPDATED/DELETED before actually executing the DML.

Day 45:
  • Simple CTE: rewrite a subquery as a CTE and use it to simplify a query.

Day 46:
  • Recursive CTE (if supported): conceptual org-chart/hierarchy; show management chain for employees.

Day 47:
  • CTE + Aggregation: use CTE as a staging step to group data and then filter or join.

Day 48:
  • Refactoring: take a long, nested query (you create) and refactor it into one or more CTEs.

Day 49:
  • Data validation: check for negative amounts, invalid dates (end_date < start_date), or impossible values.

Day 50:
  • Referential integrity checks: find child rows (Orders) without matching parent rows (Customers).

Day 51:
  • Schema design exercise: design 3 related tables and write 2–3 queries using them.

Day 52:
  • Transaction concepts (theory + some SQL): write example using BEGIN/COMMIT/ROLLBACK (syntax depending on DB).

Day 53:
  • Constraints: write CREATE TABLE with NOT NULL, UNIQUE, CHECK, and foreign key constraints.

Day 54:
  • Sample stored procedure (if DB supports): design a stored procedure to get orders by customer and date range.

Day 55:
  • Error-prone queries: intentionally write a query that double-counts due to JOIN; then fix it.

Day 56:
  • Rewrite practice: take a correlated subquery and rewrite it as a JOIN; compare performance mentally.

Day 57:
  • Multi-step problem: design queries to create a temp table/CTE, transform data, and then report results.

Day 58:
  • Leetcode-style practice: pick or simulate an interview-style SQL question (like “department with highest salary”) and solve it.

Day 59:
  • Month 2 consolidation: write 2–3 queries mixing subqueries, CTEs, and set operations.

Day 60:
  • Self-review: list concepts you still find hard and write at least 2 queries focusing on them.

----------------------------------------------------------
MONTH 3 – WINDOW FUNCTIONS & ANALYTICAL SQL (Days 61–90)
----------------------------------------------------------

Day 61:
  • Intro to window functions: use SUM() OVER() without PARTITION to show a grand total in every row.

Day 62:
  • ROW_NUMBER(): assign a row number to employees ordered by salary.

Day 63:
  • ROW_NUMBER() with PARTITION BY: row number per department by salary.

Day 64:
  • RANK() and DENSE_RANK(): rank employees by salary per department; compare RANK vs DENSE_RANK on ties.

Day 65:
  • NTILE(): split customers into 4 revenue segments using NTILE(4) over total spend.

Day 66:
  • Running totals: compute cumulative sales per customer over order_date.

Day 67:
  • Running counts: count number of orders per customer as of each order_date.

Day 68:
  • LAG(): compare current order amount to previous order amount for each customer.

Day 69:
  • LEAD(): show next order date or next subscription renewal date per customer.

Day 70:
  • FIRST_VALUE / LAST_VALUE (if supported): earliest and latest order date per customer using window functions.

Day 71:
  • Moving averages: 3-day moving average of sales; 7-day moving average of logins.

Day 72:
  • Percent of total: each department’s salary as % of total salary; each product’s revenue as % of total revenue.

Day 73:
  • Top N per group: top 3 products by revenue per category using ROW_NUMBER or RANK.

Day 74:
  • Combining window functions: use both LAG and running total in same query.

Day 75:
  • Window + CASE: mark each row as “increasing”, “decreasing”, or “same” compared to previous period.

Day 76:
  • Window + JOIN: join Customers and Orders, then use window functions to analyze customer behaviour.

Day 77:
  • Time-series differences: calculate day-over-day or month-over-month changes in metrics.

Day 78:
  • Event gaps (conceptual): identify large gaps between events using LAG on timestamps.

Day 79:
  • Recreate GROUP BY results using window functions (e.g., group totals repeated on each row).

Day 80:
  • Performance awareness: think which window queries might be heavy and how to limit partitions.

Day 81:
  • Dashboard-style queries: design 2–3 queries that could feed KPIs for a simple dashboard (e.g., revenue, active users).

Day 82:
  • Complex ORDER BY in window: partition by customer, order by date and then by amount.

Day 83:
  • Multi-step analytics: use CTE + window functions together for a more complex problem.

Day 84:
  • Real-world scenario: churn signals – use LAG to find customers inactive for more than X days.

Day 85:
  • Real-world scenario: salary banding and ranking per band using window functions.

Day 86:
  • Mixed practice: 2–3 queries using multiple window functions (ROW_NUMBER, LAG, SUM OVER).

Day 87:
  • Window + subquery: pre-aggregate with subquery/CTE then apply window calculations.

Day 88:
  • Month 3 review: mix JOIN, GROUP BY, and window functions in 2–3 queries.

Day 89:
  • Self-test: try to solve a complex interview-style SQL problem with window functions (create one yourself).

Day 90:
  • Summarize: write down in text what each window function you used does; write 1 demo query for each.

----------------------------------------------------------
MONTH 4 – DATA WAREHOUSING, MODELING & PERFORMANCE (Days 91–120)
----------------------------------------------------------

Day 91:
  • Star schema design: define fact_sales and dimensions (date, customer, product); write 2–3 queries using them.

Day 92:
  • SCD Type 1 vs Type 2 (conceptual + SQL): write queries to detect changed rows between two dimension snapshots.

Day 93:
  • Compare staging vs target tables: find rows present in staging but missing in target.

Day 94:
  • Reconciliation: compare row counts and sums between two tables; report mismatches.

Day 95:
  • Check referential integrity: find fact rows without matching dimension keys.

Day 96:
  • Data quality checks: find negative amounts, invalid statuses, or impossible dates.

Day 97:
  • Error isolation: write queries that extract bad records into an “error set”.

Day 98:
  • Change detection: find rows that need INSERT vs UPDATE vs DELETE when syncing two tables.

Day 99:
  • Idempotent loads (conceptual with SQL): write SQL logic that can run multiple times without duplicating data.

Day 100:
  • Soft delete pattern: mark rows as inactive instead of deleting; write queries filtering active vs inactive.

Day 101:
  • Audit columns: queries using created_at, updated_at to find recently changed rows.

Day 102:
  • Warehouse-style GROUP BY: aggregate fact_sales by date, by product, by region using joins to dimensions.

Day 103:
  • Drill up/down: daily → monthly → yearly aggregates; category → subcategory → product.

Day 104:
  • Bridge/many-to-many tables: simulate student–course or customer–segment relationships and query through a bridge.

Day 105:
  • Snapshot vs transaction fact (conceptual + SQL): queries that read snapshot-as-of-date vs all events.

Day 106:
  • Late-arriving dimensions (conceptual): queries that handle unknown members and retroactive updates.

Day 107:
  • Denormalization vs normalization: design normalized tables, then denormalized reporting table; write queries on both.

Day 108:
  • Partitioning concept: design a large fact_orders table partitioned by order_date; write queries targeting specific partitions.

Day 109:
  • Index basics: decide which columns to index for sample queries; explain your choice.

Day 110:
  • Query refactoring: take a long join-heavy query and simplify it or make it more readable.

Day 111:
  • Data lineage concept: track a column from source to target using SQL and documentation.

Day 112:
  • Validation queries after ETL: verify totals, counts, and duplicates across layers (staging, warehouse).

Day 113:
  • Role-playing dimensions: use date_dim multiple times (order_date, ship_date, invoice_date) in a single query.

Day 114:
  • Month 4 review: write 2–3 queries that represent typical warehouse validation/reporting tasks.

Day 115:
  • Performance scenario: describe how you’d optimize a slow query scanning a huge fact table.

Day 116:
  • Cardinality & selectivity: create example columns with different selectivity and think which are best for indexing.

Day 117:
  • Star-join optimization (conceptual): think about join order and filters for big star schemas.

Day 118:
  • Mixed practice: 2–3 queries combining star schema joins, aggregates, and filters.

Day 119:
  • Self-test: recreate a small star schema from scratch and write 5 queries over it.

Day 120:
  • Summarize data warehousing SQL patterns you now know and write 2 demo queries.

----------------------------------------------------------
MONTH 5 – CLOUD / BIG DATA-STYLE SQL (Synapse / Spark Mindset) (Days 121–150)
----------------------------------------------------------

Day 121:
  • External tables concept: write conceptual SQL to read from external CSV/Parquet files.

Day 122:
  • Columnar formats (Parquet/ORC): imagine querying Parquet; think about projecting fewer columns for performance.

Day 123:
  • Partition pruning: write SQL filtering on a partitioned date column to limit scanned data.

Day 124:
  • CTAS (CREATE TABLE AS SELECT): conceptual SQL to create aggregated tables from raw fact data.

Day 125:
  • Schema-on-read: write queries assuming flexible schema from files (handle missing columns via COALESCE).

Day 126:
  • Semi-structured JSON: write SQL to extract fields from a JSON column (using JSON_VALUE/JSON_EXTRACT-style functions).

Day 127:
  • Flatten arrays: conceptual SQL to unnest a list of items into rows.

Day 128:
  • Bucket vs partition (conceptual): describe patterns where you’d bucket by customer_id and partition by date.

Day 129:
  • MERGE-based upsert: write SQL to upsert from staging to target (INSERT new, UPDATE existing).

Day 130:
  • Incremental load via watermarks: use last_modified_date or max(order_id) to load only new data.

Day 131:
  • Snapshot table creation: CTAS or INSERT SELECT that builds a snapshot of account balances as of a given date.

Day 132:
  • Error bucketing: write a query that selects rows violating business rules into an error table.

Day 133:
  • Late-arriving facts: write SQL logic to adjust aggregates when late data shows up.

Day 134:
  • Rebuild vs incremental: design queries to either truncate-and-reload or incrementally update a summary table.

Day 135:
  • Storage tiers concept: think about querying different “bronze/silver/gold” layers and write example queries for each.

Day 136:
  • Denormalized big tables: write queries reading wide denormalized tables and consider pros/cons.

Day 137:
  • Skew & distribution (conceptual): imagine a customer_id heavily skewed; how would that affect joins?

Day 138:
  • Cost-awareness: write queries that minimize scans (filter early, select fewer columns, avoid expensive expressions).

Day 139:
  • Pipeline validation in big data: row count, sum checks, boundary checks via SQL.

Day 140:
  • Partition management: conceptual SQL to add/drop partitions for old months.

Day 141:
  • Mixed big-data practice: 2–3 queries assuming a large log_events table (user_id, event_time, event_type, metadata).

Day 142:
  • User activity patterns: write SQL to count daily active users (DAU), monthly active users (MAU), and retention.

Day 143:
  • Funnel analysis (conceptual): queries for users who performed event A then event B.

Day 144:
  • Clickstream metrics: queries on page_views or events to compute sessions, bounce rate (conceptually).

Day 145:
  • IoT-style metrics: queries on sensor_readings to find min/max/avg per device per interval.

Day 146:
  • Mixed warehouse + big data: combine dimension tables with a large fact_events table in your queries.

Day 147:
  • Month 5 review: write 2–3 queries representing big data / Synapse / Spark-style thinking.

Day 148:
  • Self-test: design your own “bronze/silver/gold” schema and write queries for each layer.

Day 149:
  • Document: write a short text explanation of how SQL is used in a cloud data pipeline and add 1–2 example queries.

Day 150:
  • Free practice: revisit any hard big-data concept and write 3 fresh queries.

----------------------------------------------------------
MONTH 6 – INTERVIEW-STYLE MIXED QUESTIONS (Days 151–180)
----------------------------------------------------------

Day 151:
  • Classic problem: find the second highest salary (several ways: subquery, window function).

Day 152:
  • Employees who joined in the last N days; employees whose salary is in top 10% of the company.

Day 153:
  • Customers who placed orders every month in the last 3–6 months (conceptual + SQL).

Day 154:
  • Customers who ordered only once vs customers who are frequent buyers.

Day 155:
  • Products never ordered; products ordered by all customers (set-related logic).

Day 156:
  • Employees with more than one manager or reporting line (based on a relationship table).

Day 157:
  • Find departments with no employees and employees without departments.

Day 158:
  • Highest-paid employee in each department; then the department with the overall highest-paid employee.

Day 159:
  • Monthly revenue trend: compute revenue per month and the month-over-month change.

Day 160:
  • Churn detection: customers whose last order was more than X days ago.

Day 161:
  • Anomaly detection: unusually high transaction amounts compared to average (e.g., > 3x average).

Day 162:
  • Top 5% earners: use window functions or subqueries to get top percentile.

Day 163:
  • Active vs inactive users: find users who logged in at least once in last 30 days vs those who didn’t.

Day 164:
  • Find users who performed event A but never event B.

Day 165:
  • Employee tenure bands: group employees by years of service and count them.

Day 166:
  • Rolling 3-month revenue per customer using window functions.

Day 167:
  • Complex join + window + CTE: design your own small case study and solve it.

Day 168:
  • ETL validation: write queries to compare source and target tables and list mismatched records.

Day 169:
  • Audit report: list all records changed in the last N days with who changed them (if you have such columns).

Day 170:
  • Slow query scenario: describe a query that might be slow and how indexes or rewrites could help.

Day 171:
  • Data quality interview-style: write queries to detect bad data and how you would handle it.

Day 172:
  • Design your own interview question about window functions and solve it fully.

Day 173:
  • Design your own interview question about subqueries/CTEs and solve it fully.

Day 174:
  • Design your own interview question about data warehousing joins and solve it fully.

Day 175:
  • Design your own interview question about big-data style SQL (files, partitions) and solve it fully.

Day 176:
  • Mock test: pick any 5 days from this plan and re-do those questions without looking at old answers.

Day 177:
  • Explain your SQL: for 2–3 of your complex queries, write a short explanation as if talking to an interviewer.

Day 178:
  • Portfolio queries: choose your best 10 queries from the entire plan and copy them into a “SQL_portfolio.sql” file.

Day 179:
  • Self-assessment: list your strongest SQL areas (joins, windows, warehousing, etc.) and your weakest.

Day 180:
  • Final recap: write 3 interview-style questions (and answers) that you think are most likely to come up in Sweden/Germany DE interviews.

End of Plan.